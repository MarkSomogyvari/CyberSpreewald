[{"name": "app.py", "content": "from shiny import *#App, render, ui\nfrom main1 import model_channels, plot_stuff\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_switch(\"w1\", \"Open weir\", value = False),\n        ),\n        ui.panel_main(\n            ui.output_plot(\"pie\"), width = '50%', height = '100%'\n        ),\n    ),\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot(alt=\"A histogram\")\n    \n    def pie():\n\n\n        sf, P_new, V = model_channels(W=input.w1())\n        fig = plot_stuff(sf, P_new, V)\n\n        return fig\n\n\n\n\napp = App(app_ui, server, debug=True)", "type": "text"}, {"name": "main1.py", "content": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport pandas as pd\n\nimport scipy.sparse\nimport scipy.sparse.linalg\n\n\ndef model_channels(W):\n    # define structure\n    d = {'Xb': [1, 1, 1, 1, 0, 0, 1, 1, 2, 0, 0, 1, 1, 2, 1], \n     'Yb': [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4], \n     'Xe': [1, 0, 1, 2, 1, 0, 2, 1, 2, 1, 1, 2, 1, 1, 1], \n     'Ye': [1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 4, 3, 4, 4, 5],\n     'Width': [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n     'Name': ['OA','AB','AC','AD','BC','BE','CD','CF','DG','EF','EH','FG','FH','GH', 'HI']}\n    df = pd.DataFrame(data=d)\n\n    #Support geometry functions\n    def section_len(df):\n        return ((df.Xe-df.Xb)**2+(df.Ye-df.Yb)**2)**0.5\n\n    def section_angle(df):\n        return np.arctan((df.Ye-df.Yb)/(df.Xe-df.Xb))\n    \n    # Segmentation\n    dx = 0.1\n    L = section_len(df)\n    alpha = section_angle(df)\n    X_len = df.Xe-df.Xb \n    Y_len = df.Ye-df.Yb\n    ids = 0\n\n    DFN_Mat2 = np.array([[],[],[],[],[],[],[]]).T\n    for i in range(0,len(df)):\n        n_seg = np.floor(L[i]/dx)\n        d_seg = L/n_seg\n\n        for j in range(0,int(n_seg)):\n            newline00 = int(ids)\n            newline0 = df.Xb[i] + j*X_len[i]/n_seg\n            newline1 = df.Yb[i] + j*Y_len[i]/n_seg\n            newline2 = df.Xb[i] + (j+1)*X_len[i]/n_seg\n            newline3 = df.Yb[i] + (j+1)*Y_len[i]/n_seg\n            newline4 = df.Width[i]\n            newline5 = df.Name[i]\n            \n            DFN_Mat2 = np.vstack([DFN_Mat2,[newline00,newline0,newline1,newline2,newline3,newline4,newline5]])\n            ids = ids+1\n            \n\n    sf = pd.DataFrame(DFN_Mat2, columns = ['id','Xb','Yb','Xe','Ye','Width','Name'])\n    sf.iloc[:,1:6] = sf.iloc[:,1:6].astype('float')\n\n    sf.Xb[87] =  sf.Xb[87]+0.05*W\n\n    #Connectivity matrix\n    eps = 0.001\n    Connect_Mat = np.ones([len(sf),6])*(-999) \n\n\n    for i in range(0,len(sf)):\n            D55 = abs(sf.Xb[:]-sf.Xb[i])\n            D66 = abs(sf.Yb[:]-sf.Yb[i])\n            D77 = abs(sf.Xe[:]-sf.Xe[i])\n            D88 = abs(sf.Ye[:]-sf.Ye[i])\n            D57 = abs(sf.Xe[:]-sf.Xb[i])\n            D68 = abs(sf.Ye[:]-sf.Yb[i])\n            D75 = abs(sf.Xb[:]-sf.Xe[i])\n            D86 = abs(sf.Yb[:]-sf.Ye[i])\n            \n            index = np.where(((D55<=eps) & (D66<=eps)) | ((D77<=eps) & (D88<=eps)) | ((D57<= eps) & (D68<=eps)) | ((D75<=eps) & (D86<=eps)))\n            k = 0\n            for j in range(0,min(5,len(index[0]))):\n                if (index[0][j]!=i):\n                    Connect_Mat[i,k] = index[0][j]\n                    k = k+1\n\n\n    #Physics part\n    #Boundary conditions (pressure for now)\n    BC_coord = np.array(((-1,1,0),(1,1,5)))\n\n    P_Inj = 1     # Injection pressure [Pa]\n    P_Prod = 0    # Production pressure [Pa]\n    P_ini = 0    # Initial pressure in the fractures [Pa]\n\n\n    # +++++++++++++++ these need to be adjusted:\n    Dt_P = 10      # Pressure time step for steady state [sec]\n    DP_time = 10000\n    n_time_P = int(DP_time/Dt_P) # Maximum number of pressure time steps\n\n    num_Frac = len(sf)\n\n    AP = np.zeros([num_Frac,num_Frac])  # Init pressure conductivity Matrix(LHS)\n    BP = np.zeros(num_Frac)# Init pressure storativity Vector (RHS)\n\n\n\n    #Solve for steady-state pressure\n    tp = -1\n    #timeP = np.linspace(Dt_P,DP_time,n_time_P)\n\n    #P_new = [0]*num_Frac\n    BP = np.zeros(num_Frac)\n    APl = np.copy(AP)   #Local variable\n\n    #Hydraulic parameters\n    Gamma_P = np.zeros(num_Frac)\n    Gamma_P_tot = np.zeros(num_Frac)\n    Etha_P = np.zeros(num_Frac)\n\n    Ls = section_len(sf)\n    #A = 1 #aperture originally\n    V = 1 #viscosity originally\n    C = 1 # fluid compressibility originally\n\n\n    for i in range(0,num_Frac):\n            Gamma_P[i] = Dt_P*sf.Width[i]**3/(6*V*Ls[i])   # Transmissivity 1\n            Etha_P[i] = sf.Width[i]*C*Ls[i]                 # Storativity 1\n\n\n    for i in range(0,num_Frac):\n        Gamma_P_tot[i] = Gamma_P[i]\n        for j in range(0,6):\n            cn = int(Connect_Mat[i,j])\n            if (cn >= 0):\n                Gamma_P_tot[i] = Gamma_P_tot[i] + Gamma_P[cn]   # if and g1g2 based on index\n                AP[i,cn] = Gamma_P[i]*Gamma_P[cn]\n                AP[i,i] = AP[i,i]-Gamma_P[i]*Gamma_P[cn]\n        AP[i,i] = AP[i,i]/Gamma_P_tot[i] - Etha_P[i]\n        for j in range(0,6):\n            cn = int(Connect_Mat[i,j])\n            if (cn >= 0):\n                AP[i,cn] = AP[i,cn]/Gamma_P_tot[i]\n\n    #SOLVER\n     # Solve Finite Difference pressure\n    P_old = np.ones(num_Frac)\n    P_new = np.zeros([n_time_P,num_Frac])    \n\n    tp = -1\n    while (tp < n_time_P-1):\n        tp = tp + 1\n\n        #Apply initial conditions\n        if (tp==0):\n            P_old = P_old*P_ini     # Initial pressure\n        else:\n            P_old[0:num_Frac] = P_new[tp-1,:]\n\n    #            for i in range(0,num_Frac):\n    #                BP[i] = -Etha_P[i]*P_old[i]\n        BP = -Etha_P*P_old\n\n        # Apply boundary conditions\n        APl[0,:] = 0                      #ASK REZA - does not do a lot\n        APl[0,0] = 1\n        BP[0] = P_Inj\n        \n        APl[len(sf)-1,:] = 0\n        APl[len(sf)-1,len(sf)-1] = 1\n        BP[len(sf)-1] = P_Prod\n        \n        # Injection points\n        #APl[int(Inj_id[idinj]),:] = 0\n        #APl[int(Inj_id[idinj]),int(Inj_id[idinj])] = 1\n        #BP[int(Inj_id[idinj])] = P_Inj\n        \n        #Production points\n    #        for i in range(0,np.shape(Prod_id)[0]):\n    #            APl[int(Prod_id[i]),:] = 0\n    #            APl[int(Prod_id[i]),int(Prod_id[i])] = 1\n    #            BP[int(Prod_id[i])] = P_Prod\n\n        # Solver for pressure\n        #AP2 =  #SPARSE MATRIX NEEDED for performance\n        AP2 = scipy.sparse.csc_matrix(APl)\n\n        P_new[tp,:] = scipy.linalg.solve(AP,BP.T) #standard solution\n        #P_new[tp,:] = scipy.sparse.linalg.spsolve(AP2,BP.T,permc_spec='MMD_ATA') #Fastest but can be singular\n        #P_new[tp,:] = scipy.linalg.lstsq(AP,BP.T)[0] #numerical approx\n        \n    tss = tp\n\n    P_new = P_new[0:tss+1,:]\n\n    #Estimate velocity\n    num_up = np.zeros(num_Frac)\n    V = np.zeros(num_Frac)\n    for i in range(0,num_Frac):\n        P_Max = P_new[tss,i]\n        num_up[i] = i\n        for j in range(0,6):\n            cn = int(Connect_Mat[i,j])\n            if (cn >= 0 and P_new[tp,cn] > P_Max):\n                P_Max = P_new[tp,cn]\n                num_up[i] = cn\n\n            V[i] = 1**2/(12*1*2)*(P_Max-P_new[tp,i])\n\n\n    return sf, P_new, V\n\n\ndef plot_stuff(sf,P_new,V):\n    fig = plt.figure()#figsize = [12,6])\n    plt.subplot(2,2,1)\n    plt.title('Channel structure')\n    for i in range(0,len(sf)):\n        plt.plot([sf.Xb[i],sf.Xe[i]],[sf.Yb[i],sf.Ye[i]],lw=sf.Width[i]*2)\n        #plt.text(sf.Xb[i],sf.Yb[i],str(sf.id[i]))\n        \n        \n    plt.subplot(2,2,2)\n    plt.title('P convergence')\n    plt.plot(P_new[:,23])\n\n    plt.subplot(2,2,3)\n    plt.title('Head distribution')\n    time = np.shape(P_new)[0]-1\n    P_norm = (P_new[time,:]-min(P_new[time,:]))/(max(P_new[time,:])-min(P_new[time,:]))\n    cmap = matplotlib.cm.get_cmap('jet')\n\n    for i in range(0,len(sf)):\n        plot = plt.plot([sf.Xb[i],sf.Xe[i]],[sf.Yb[i],sf.Ye[i]],color=cmap(P_norm[i]))\n        \n        \n    plt.subplot(2,2,4)\n    plt.title('Discharge')\n    V2 = V*sf.Width*1\n    V2_norm = (V2-min(V2))/(max(V2)-min(V2))\n    cmap = matplotlib.cm.get_cmap('jet')\n\n    for i in range(0,len(sf)):\n        plt.plot([sf.Xb[i],sf.Xe[i]],[sf.Yb[i],sf.Ye[i]],color=cmap(V2_norm[i]))\n    plt.tight_layout()\n    return fig\n\n\nsf, P_new, V = model_channels(1)\nplot_stuff(sf, P_new, V)", "type": "text"}, {"name": "manifest.json", "content": "{\n  \"version\": 1,\n  \"locale\": \"en_DE.cp1252\",\n  \"metadata\": {\n    \"appmode\": \"python-shiny\",\n    \"entrypoint\": \"app\"\n  },\n  \"python\": {\n    \"version\": \"3.8.13\",\n    \"package_manager\": {\n      \"name\": \"pip\",\n      \"version\": \"23.2.1\",\n      \"package_file\": \"requirements.txt\"\n    }\n  },\n  \"files\": {\n    \"requirements.txt\": {\n      \"checksum\": \"859c636d95b8d0ec057b0ef1d4e425ac\"\n    },\n    \"app.py\": {\n      \"checksum\": \"faae44e2568c2bf23ef1610309db90e5\"\n    },\n    \"main1.py\": {\n      \"checksum\": \"037a7932cc67cd7c09d47d4ae9561175\"\n    }\n  }\n}\n", "type": "text"}, {"name": "requirements.txt", "content": "# requirements.txt generated by rsconnect-python on 2023-07-30 16:51:14.783250\nanyio==3.7.1\nappdirs==1.4.4\nasgiref==3.7.2\nBottleneck\nbrotlipy==0.7.0\ncertifi\ncffi\ncharset-normalizer\nclick==8.1.6\ncolorama==0.4.6\ncontextvars==2.4\ncontourpy\ncryptography\ncycler\nexceptiongroup==1.1.2\nfonttools==4.25.0\nh11==0.14.0\nhtmltools==0.2.1\nidna\nimmutables==0.19\nimportlib-resources\nkiwisolver\nlinkify-it-py==2.0.2\nmarkdown-it-py==3.0.0\nmatplotlib\nmdit-py-plugins==0.4.0\nmdurl==0.1.2\nmkl-fft==1.3.6\nmkl-random\nmkl-service==2.4.0\nmunkres==1.1.4\nnumexpr\nnumpy==1.24.4\npackaging\npandas\nPillow==9.4.0\nply==3.11\npooch\npycparser\nPyJWT==2.8.0\npyOpenSSL\npyparsing\nPyQt5==5.15.7\nPyQt5-sip\nPySocks\npython-dateutil\npython-multipart==0.0.6\npytz\nrequests\nscipy==1.10.1\nsemver==2.13.0\nshiny==0.4.0\nsip\nsix\nsniffio==1.3.0\nstarlette==0.31.0\ntoml\ntornado\ntyping_extensions==4.7.1\nuc-micro-py==1.0.2\nurllib3\nuvicorn==0.23.1\nwatchfiles==0.19.0\nwebsockets==11.0.3\nwin-inet-pton\nzipp\n", "type": "text"}]